---
name: expressive-refactor
description: 주석을 배제하고 클로저와 메서드 체이닝을 활용해 코드의 표현력(Expressive Code)을 극대화하는 리팩토링 스킬입니다. 코드 리팩토링, 클린 코드, 가독성 개선 요청 시 사용합니다.
---

# Expressive Refactor Guide

이 스킬은 "주석은 변명이다"라는 철학을 바탕으로, 코드를 '설명'하는 대신 '표현'하게 만듭니다. 클로저로 상태를 은닉하고, 메서드 체이닝으로 문장 같은 흐름을 구축하여 수필처럼 읽히는 코드를 지향합니다.

## 1. 핵심 철학: Expressive Code

- **주석 최소화**: 로직을 설명하는 주석은 코드의 실패를 의미합니다. 주석을 달기 전, 함수명과 변수명을 개선하여 의도를 드러내십시오.
- **문맥(Context)의 격리**: 복잡한 로직은 읽는 이에게 노이즈가 됩니다. 캡슐화를 통해 필요한 정보만 노출하십시오.
- **선언적 지향**: '어떻게(How)' 하는지 절차를 나열하지 말고, '무엇(What)'을 하려는지 결과 중심으로 작성하십시오.

## 2. 기술적 지침 (Technical Guidelines)

### A. 클로저 & IIFE를 통한 스코프 오염 방지

특정 계산이나 초기화에만 쓰이는 임시 변수들은 외부 스코프를 오염시키지 않도록 즉시 실행 함수(IIFE)나 클로저 내부에 가두십시오.

```javascript
// Good: IIFE를 통한 의미 단위 캡슐화
const finalPrice = (() => {
  const basePrice = 10000;
  const tax = 1.1;
  const discount = user.isMember ? 0.1 : 0;
  return basePrice * (1 - discount) * tax;
})();
```

### B. 유려한 메서드 체이닝 (Fluent Interface)

비즈니스 로직의 연속성을 표현할 때는 `this`를 반환하여 호출자가 문장을 읽는 듯한 경험을 하게 만드십시오.

- 클래스나 객체 리터럴의 메서드에서 적극적으로 `return this;`를 활용합니다.
- 각 체이닝 요소는 한 줄에 하나씩 배치하여 시각적 흐름을 유지합니다.

### C. 서술적 조건식 (Predicate Extraction)

복잡한 논리 연산자는 그 자체로 암호가 됩니다. 비즈니스 언어를 담은 변수나 함수로 추출하십시오.

- `if (user.isActive && user.lastLogin > lastWeek)` (X)
- `if (user.isRecentActiveUser())` (O)

## 3. 리팩토링 수행 단계 (Execution Steps)

1. **주석 식별**: 파일 내 모든 주석을 찾아 해당 주석이 설명하는 로직을 코드로 표현할 방법을 찾습니다.
2. **스코프 정리**: 상위 스코프에 널브러진 임시 변수들을 IIFE나 별도 함수로 격리합니다.
3. **흐름 연결**: 절차적으로 나열된 함수 호출들을 가능하다면 메서드 체이닝 형태로 재구성합니다.
4. **선언형 전환**: `for`, `while` 문을 `map`, `filter`, `reduce` 등의 고차 함수로 교체합니다.

## 4. 최종 체크리스트 (Quality Gate)

- [ ] 코드가 영어 문장처럼 막힘없이 읽히는가?
- [ ] 불필요한 임시 변수가 완전히 제거되거나 격리되었는가?
- [ ] "왜 이렇게 짰지?"라는 의문이 드는 지점에 주석 대신 더 명확한 이름이 쓰였는가?
- [ ] 로직의 '호흡'이 중간에 끊기지 않고 유려하게 이어지는가?
